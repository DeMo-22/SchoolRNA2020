---
title: "Glossary of terms"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 3
    code_folding: show
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

<style>

body,p,h1,h2,h3,h4,h5,h6 {
  text-align: justify;
  color: #424949;
  font-weight: 400;
  font-size: 14px;
  line-height: 1.55;}

h1 {  font-size: 1.4em;font-weight: bold; }
h2 {  font-size: 1.2em;font-weight: bold; }
h3 {  font-size: 1.1em;font-weight: bold; }
h4 {  font-size: 1.0em;font-weight: bold; }

pre {
  font-family: "Courier";
  background-color: #F7F7F7;
  border: 1px solid #CCCCCC;
  font-size: 14px;}

code {
  font-family: "Courier New";
  font-size: 14px;
  word-break: break-all;
  font-weight: bold;}

</style>


```{r, include=F, result='hide'}
library(Seurat)
library(Matrix)
library(hdf5r)
```


# Download data
***

```{bash, include=F, result='hide'}
mkdir data

curl -o data/pbmc_1k_v2_filtered_feature_bc_matrix.h5 -O http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v2/pbmc_1k_v2_filtered_feature_bc_matrix.h5

curl -o data/pbmc_1k_v3_filtered_feature_bc_matrix.h5 -O http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/pbmc_1k_v3_filtered_feature_bc_matrix.h5

curl -o data/pbmc_1k_protein_v3_filtered_feature_bc_matrix.h5 -O http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_protein_v3/pbmc_1k_protein_v3_filtered_feature_bc_matrix.h5
```

<br/>

<br/>

# Load data
***

## Reading files

There are many formats available in which one can store single cell information. Either 1) using tab-delimited matricies saved as `.csv` or `.tsv` and with and additional matrix containing the sample metadata, which is common for SMARTseq2 and related methods; 2) using a compressed sparce matrix file `.mtx` with annotations for genes and cells saved as `.tsv`, which was one of the defaults for 10X Chromium data; 3) using HDF5 compressed file for in-file read-write access, which is now becoming the default method for storing single cell dataset (is the current default for 10X Chromium data). HDF5 in particular is fast, scalable and can load parts of the data that will be used at a time, and also can store the metadata in the same file, making it portable.

We can for instance load the data individually by reading directly from HDF5 file format (.h5). Note that among those, the dataset p3.1k actually has both gene expression and CITE-seq data, so we will use only the Gene Expression here.

```{r,  results='hold'}
v3.1k <- Read10X_h5("data/pbmc_1k_v3_filtered_feature_bc_matrix.h5", use.names = T)
v2.1k <- Read10X_h5("data/pbmc_1k_v2_filtered_feature_bc_matrix.h5", use.names = T)
p3.1k <- Read10X_h5("data/pbmc_1k_protein_v3_filtered_feature_bc_matrix.h5", use.names = T)

## Genome matrix has multiple modalities, returning a list of matrices for this genome
p3.1k <- p3.1k$`Gene Expression`
```

<br/>

## Creating Seurat objects

We can now load the expression matricies into objects and then merge them into a single merged object. Each analysis workflow (Seurat, Scater, Scranpy, etc) has its own way of storing data.

```{r,  results='hold'}
SeuratObject.v2.1k <- CreateSeuratObject(v2.1k, project = "v2.1k")
SeuratObject.v3.1k <- CreateSeuratObject(v3.1k, project = "v3.1k")
SeuratObject.p3.1k <- CreateSeuratObject(p3.1k, project = "p3.1k")
```

<br/>

## Merge datasets into one single seurat object

```{r,  results='hold'}
SeuratObject <- merge(SeuratObject.v2.1k,
                 c(SeuratObject.v3.1k,SeuratObject.p3.1k),
                 add.cell.ids=c("v2.1k","v3.1k","p3.1k"))
dim(SeuratObject)
```

<br/>

## Add in a metadata column

```{r,  results='hold'}
SeuratObject$Chemistry <- ifelse(SeuratObject$orig.ident == "v2.1k","v2","v3")
```


<br/>

<br/>

# Quality control
***

<br/>

## Total no. of features

A standard approach is to filter cells with low amount of reads as well as genes that are present in at least a certain amount of cells. Here we will only consider cells with at least 200 detected genes and genes need to be expressed in at least 3 cells. Please note that those values are highly dependent on the library preparation method used. Extremely high number of detected genes could indicate doublets. However, depending on the cell type composition in your sample, you may have cells with higher number of genes (and also higher counts) from one cell type.

```{r,  results='hold'}
VlnPlot(SeuratObject,
        group.by= "orig.ident",
        features = c("nFeature_RNA","nCount_RNA"),
        pt.size = 0.1,
        ncol = 4) + NoLegend()
```


<br/>

## Gene QC

In single cell, the most detected genes usually belong to housekeeping gene families, such as mitochondrial (MT-), ribossomal (RPL and RPS) and other structural proteins (i.e., ACTB, TMSB4X, B2M, EEF1A1)

```{r  }
#Compute the relative expression of each gene per cell
rel_expression <- t( t(SeuratObject@assays$RNA@counts) / Matrix::colSums(SeuratObject@assays$RNA@counts)) * 100
most_expressed <- sort(Matrix::rowSums( rel_expression ),T) / ncol(SeuratObject)

par(mfrow=c(1,3),mar=c(4,6,1,1))
boxplot( as.matrix(t(rel_expression[names(most_expressed[30:1]),])),cex=.1, las=1, xlab="% total count per cell",col=scales::hue_pal()(20)[30:1],horizontal=TRUE)
boxplot( as.matrix(t(rel_expression[names(most_expressed[60:31]),])),cex=.1, las=1, xlab="% total count per cell",col=scales::hue_pal()(20)[60:31],horizontal=TRUE)
boxplot( as.matrix(t(rel_expression[names(most_expressed[90:61]),])),cex=.1, las=1, xlab="% total count per cell",col=scales::hue_pal()(20)[90:61],horizontal=TRUE)
```

As you can see, MALAT1 constitutes up to 30% of the UMIs from a single cell and the other top genes are mitochondrial and ribosomal genes. It is quite common that nuclear lincRNAs have correlation with quality and mitochondrial reads, so high detection of MALAT1 may be a technical issue. Let us assemble some information about such genes, which are important for quality control and downstream filtering.

## % Mitochondrial genes

Having the data in a suitable format, we can start calculating some quality metrics. We can for example calculate the percentage of mitocondrial and ribosomal genes per cell and add to the metadata. This will be helpfull to visualize them across different metadata parameteres (i.e. datasetID and chemistry version). There are several ways of doing this, and here manually calculate the proportion of mitochondrial reads and add to the metadata table.

Citing from “Simple Single Cell” workflows (Lun, McCarthy & Marioni, 2017): “High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), possibly because of loss of cytoplasmic RNA from perforated cells. The reasoning is that mitochondria are larger than individual transcript molecules and less likely to escape through tears in the cell membrane.”

```{r,  }
# Calculating % mitochondrial genes
SeuratObject <- PercentageFeatureSet(SeuratObject, 
                                     pattern = "^MT-",
                                     col.name = "percent_mito")

VlnPlot(SeuratObject,
        group.by= "orig.ident",
        features = c("percent_mito"),
        pt.size = 0.1,
        ncol = 4,y.max = 100) + NoLegend()
```

<br/>

## % Ribossomal genes

In the same manner we will calculate the proportion gene expression that comes from ribosomal proteins.

```{r,  }
# Calculating % ribossomal genes
SeuratObject <- PercentageFeatureSet(SeuratObject, 
                                     pattern = "^RP[SL]", 
                                     col.name = "percent_ribo")

VlnPlot(SeuratObject,
        group.by= "orig.ident",
        features = c("percent_ribo"),
        pt.size = 0.1,
        ncol = 4,y.max = 100) + NoLegend()
```


<br/>

## Removal of cells

```{r,  results='hold'}
#start with cells with many genes detected.
high.det.v3 <- WhichCells(
  SeuratObject,
  expression = nFeature_RNA > 4100)

high.det.v2 <- WhichCells(
  SeuratObject,
  expression = nFeature_RNA > 2000 &
               orig.ident == "v2.1k")

SeuratObject.filt <- subset(
  SeuratObject,
  cells=setdiff(
    WhichCells(SeuratObject),
    c(high.det.v2,high.det.v3))
  )

# remove cells with abnormal mitochodrial and ribossomal gene percentages
selected_mito <- WhichCells(
  SeuratObject.filt, 
  expression = percent_mito < 25)

selected_ribo <- WhichCells(
  SeuratObject.filt,
  expression = percent_ribo > 5)

SeuratObject.filt <- subset(
  SeuratObject.filt,
  cells = selected_ribo [selected_ribo %in% selected_mito ])
```


```{r,  }
VlnPlot(SeuratObject,
        group.by= "orig.ident",
        features = c("nFeature_RNA","nCount_RNA","percent_mito","percent_ribo"),
        pt.size = 0.1,
        ncol = 4) + NoLegend()

VlnPlot(SeuratObject.filt,
        group.by= "orig.ident",
        features = c("nFeature_RNA","nCount_RNA","percent_mito","percent_ribo"),
        pt.size = 0.1,
        ncol = 4) + NoLegend()
```

<br/>


## Gene biotype and chromossome location

In RNA-sequencing, genes can be categorized into different groups depending on their RNA biotype. For example, "coding", "non-coding", "VDJ region genes" are "small interefering RNA" common gene biotypes. Besides, having information about chromossomal location might be usefull to identify bacth effects driven by sex chromossomes.

Depending on the desired type of analysis, some gene categories can be filtered out if not of interest. For single cell specifically, cell libraries are usually constructed using poly-A enrichment and therefore enriching for "protein-coding proteins", which usually contitutes around 80-90% of all available genes.

How to run it:

```{r,  }
library(biomaRt)
mart = useMart("ensembl", 
               dataset = paste0("hsapiens_gene_ensembl"),
               host="jul2019.archive.ensembl.org")
annot <- getBM(c("external_gene_name",
                 "gene_biotype",
                 "chromosome_name"),
               mart = mart)


par(mfrow=c(1,2),mar=c(4,6,1,1))
# Plot expression per gene_biotype
item <- annot[match(rownames(SeuratObject@assays$RNA@counts) , annot[,1]),"gene_biotype"]
item[is.na(item)] <- "unknown"
temp <- rowsum(as.matrix(SeuratObject@assays$RNA@counts),group=item)
o <- order(apply(temp,1,median),decreasing = F)
boxplot( (t(temp)/Matrix::colSums(SeuratObject@assays$RNA@counts))[,o]*100,outline=F,las=2,main="% reads per cell",col=scales::hue_pal()(100),horizontal=T)

# Plot expression per chromosome_name
item <- annot[match(rownames(SeuratObject@assays$RNA@counts) , annot[,1]),"chromosome_name"]
item[is.na(item)] <- "unknown"
item[! item %in% as.character(c(1:23,"X","Y","MT")) ] <- "other"
temp <- rowsum(as.matrix(SeuratObject@assays$RNA@counts),group=item)
o <- order(apply(temp,1,median),decreasing = F)
boxplot( (t(temp)/Matrix::colSums(SeuratObject@assays$RNA@counts))[,o]*100,outline=F,las=2,main="% reads per cell",col=scales::hue_pal()(100),horizontal=T)
```

If you want to focus the analysis on only protein-coding genes, you can do it so:

```{r,  }
dim(SeuratObject)
sel <- annot[match(rownames(SeuratObject) ,
                   annot[,1]),2] == "protein_coding"
genes_use <- rownames(SeuratObject)[sel]
genes_use <- as.character(na.omit(genes_use))
SeuratObject <- SeuratObject[genes_use,]
dim(SeuratObject)
```

## Cell cycle

We here perform cell cycle scoring. To score a gene list, the algorithm calculates the difference of mean expression of the given list and the mean expression of reference genes. To build the reference, the function randomly chooses a bunch of genes matching the distribution of the expression of the given list. Cell cycle scoring adds three slots in data, a score for S phase, a score for G2M phase and the predicted cell cycle phase.

How to run it:

```{r,  }
SeuratObject <- CellCycleScoring(
  object = SeuratObject,
  g2m.features = cc.genes$g2m.genes,
  s.features = cc.genes$s.genes)

SeuratObject$G1.Score <- 1 - SeuratObject$S.Score - SeuratObject$G2M.Score
```

Plot:

```{r,  }
VlnPlot(SeuratObject,
        features = c("S.Score","G2M.Score","G1.Score"),
        group.by= "orig.ident",
        ncol = 4,
        pt.size = .1)
```


<br/>

<br/>

# Normalization and Regression
***

## Normalization

The most common normalization for RNA-seq and also single-cell RNA-seq is log-normalization. This is done by dividing the gene counts of each gene by the sum of all gene counts (a.k.a., library size) to compensate for library size differences. Then the result is multiplied by a constant number, so all cell have the same sequencing depth. For bulk RNA-seq, the constant is usually $1e6$, resulting in CPM (counts per million), but since single-cells library sizes are way lower than that, the number ranges from $1e3$ to $1e4$ (counts per 10000).

$$NormCounts = \frac{GeneCounts * 10000}{LibrarySize}$$
The library size-corrected values are then log-transformed to achieve a log-normal data distribution.

$$logNormCounts = ln(NormCounts+1)$$

How to run it:

```{r,  }
SeuratObject <- NormalizeData(
  object = SeuratObject,
  scale.factor = 10000,
  normalization.method = "LogNormalize")
```


## Scaling and Centering (linear)

Since each gene has a different expression level, it means that genes with higher expression values will naturally have higher variation that will be captured by downstream methods. This means that we need to somehow give each gene a similar weight beforehand (see below). A common practice is to center and scale each gene before performing PCA. This exact scaling is called Z-score normalization it is very useful for PCA, clustering and plotting heatmaps.

Additionally, we can use regression to remove any unwanted sources of variation from the dataset, such as cell cycle, sequencing depth, percent mitocondria. This is achieved by doing a generalized linear regression (GLM) using these parameters as covariates in the model. Then the residuals of the model are taken as the “regressed data”. Although perhaps not in the best way, batch effect regression can also be done here.

How to run it:

```{r,  }
SeuratObject <- ScaleData(
  object = SeuratObject,
  vars.to.regress = c("nCount_RNA","mito.percent","nFeatures"),
  model.use = "linear",
  do.scale = T,
  do.center = T)
```


## Scaling and Centering (poisson)

Since the procedure above assumes a log-linear data distribution, it may be the case that it does not regress the variation correctly, as RNA-seq data (including single cell) relates more closely to a negative bionomial distribution. An alternative variation of the procedure above can also be run on the raw UMI count data but using a "poisson" or "negative binomial" distribution instead. This is performing a gene-wise GLM regression using a poisson model.

How to run it:

```{r,  }
SeuratObject <- ScaleData(
  object = SeuratObject,
  vars.to.regress = c("nCount_RNA","mito.percent","nFeatures"),
  model.use = "poisson",
  do.scale = T,
  do.center = T)
```

## SCtransform

Scaling and centering assuming a poisson distribution might in some cases overfit the data, see above. One can overcome this by pooling information across genes with similar abundances in order to obtain more stable parameter estimates to be used as gene weights in the regression model. This is called "scTransform" and, in simple terms, is performing a gene-wise GLM regression using a constrained negative binomial model.

How to run it:

```{r,  }
SeuratObject <- SCTransform( 
  object = SeuratObject,
  assay="RNA",
  vars.to.regress =  c("nCount_RNA","mito.percent","nFeatures"),
  new.assay.name = "sctransform",
  do.center=T )
```

# Feature selection
***

An important step in many big-data analysis tasks is to identify features (genes, transcripts, proteins, metabolites, etc) that are actually very variable between the samples being looked at.

For example. Imagine that you have a dataset known to contain different types of epithelial cells, and you use either 1) only genes that are expressed and shared across all epithelial cells at about the same level, 2) only genes that are not detected in epithelial cells, 3) only genes which expression differ greatly across epithelial cells or 4) using all genes. Which of these 4 gene lists can best distinguish the epithelial subtypes in this dataset?

As you could now imagine, using only genes which expression differ greatly across epithelial cells is the best case scenario, followed by using al genes. Therefore, using only genes that are expressed and shared across all epithelial cells at about the same level or only genes that are not detected in epithelial cells do not contain sufficient information to distinguish the epithelial subtypes.

However, since in single-cell we usually do not know the epithelial suptypes the cells before hand (since this is what we want to discover), we need another method to acomplish this task. In general terms, a common approach is to order genes by their overal variance across samples. This is because genes with higher variance will also likely be the ones that can separate the cells the best.

Since genes with higher expression level usually also have naturally higher variation, the gene variation is then normalized by the log  mean expression of each gene (see plot). 

How to run it:

```{r,  }
SeuratObject <- FindVariableFeatures(
  object = SeuratObject,
  nfeatures = 3000,
  selection.method = "vst",
  verbose = FALSE,
  assay = "RNA",
  dispersion.function = FastLogVMR,
  mean.function = FastExpMean)
```

Variable gene plot:

```{r,  }
top20 <- head(VariableFeatures(alldata), 20)
LabelPoints(plot = VariableFeaturePlot(alldata), points = top20, repel = TRUE)
```

# Intro to Graphs
***

## KNN

KNN refers to “K Nearest Neighbors”, which is a basic and popular topic in data mining and machine learning areas. The KNN graph is a graph in which two vertices p and q are connected by an edge, if the distance between p and q is among the K-th smallest distances.[2] Given different similarity measure of these vectors, the pairwise distance can be Hamming distance, Cosine distance, Euclidean distance and so on. We take Euclidean distance as the way to measure similarity between vectors in this paper. The KNN Graph data structure has many advantages in data mining. For example, for a billion-level dataset, prebuilding a KNN graph offline as an index is much better than doing KNN search online many times.

<div style="text-align: right"> Adapted from [Github](https://github.com/lengyyy/KNN-Graph) </div>

```{r,  }
SeuratObject <- FindNeighbors(SeuratObject,
                              assay = "RNA",
                              compute.SNN = F,
                              reduction = "pca",
                              dims = 1:50,
                              graph.name="SNN",
                              prune.SNN = 1/15,
                              k.param = 20,
                              force.recalc = T)
```

Setting `compute.SNN` to `FALSE` will only compute the k-NN graph.

We can take a look at the kNN graph. It is a matrix where every connection between cells is represented as 1
s. This is called a unweighted graph (default in Seurat). Some cell connections can however have more importance than others, in that case the scale of the graph from 0
 to a maximum distance. Usually, the smaller the distance, the closer two points are, and stronger is their connection. This is called a weighted graph. Both weighted and unweighted graphs are suitable for clustering, but clustering on unweighted graphs is faster for large datasets (> 100k cells).
 
```{r,  }
library(pheatmap)
pheatmap(alldata@graphs$CCA_nn[1:200,1:200],
         col=c("white","black"),border_color = "grey90",
         legend = F,cluster_rows = F,cluster_cols = F,fontsize = 2) 
```

## SNN

In addition to the k-NN graph, if we then determine the number of nearest neighbors shared by any two points. In graph terminology, we form what we call the "shared nearest neighbor" graph. We do this by replacing the weight of each link between two points (in the nearest neighbor graph) by the number of neighbors that the points share. In other words, this is the number of length 2 paths
between any two points in the nearest neighbor graph [7].

After, this shared nearest neighbor graph is created, all pairs of points are compared and if any two points share more than T neighbors, i.e., have a link in the shared nearest neighbor graph with a weight more than our threshold value, T( TS:. n), then the two points and any cluster they are part of are merged. In other words, clusters are connected components in our shared nearest neighbor graph after we sparsify using a threshold.

How to run it:

```{r,  }
SeuratObject <- FindNeighbors(SeuratObject,
                              assay = "RNA",
                              compute.SNN = T,
                              reduction = "pca" 
                              dims = 1:50,
                              graph.name="SNN",
                              prune.SNN = 1/15,
                              k.param = 20,
                              force.recalc = T)
```

Setting `compute.SNN` to `TRUE` will compute both the k-NN and SNN graphs.

<br/>

<br/>

# Dimensionality reduction
***

<br/>

## PCA

Principal Component Analysis (PCA) is defined as an orthogonal **linear** transformation that transforms the data to a new coordinate system such that **the greatest variance by some scalar projection of the data comes to lie on the first coordinate** (called the first principal component), the second greatest variance on the second coordinate, and so on. […] Often, its operation can be thought of as revealing the internal structure of the data in a way that best explains the variance in the data. […] This is done by **using only the first few principal components** so that the dimensionality of the transformed data is reduced.

<div style="text-align: right"> Adapted from [Wikipedia](https://en.wikipedia.org/wiki/Principal_component_analysis) </div>

How to run it:
```{r,  }
SeuratObject <- RunPCA(object = SeuratObject,
                       assay = "RNA",
                       npcs = 100,
                       verbose = FALSE )
```

<br/> 

<br/> 

## tSNE

<div style="text-align: right"> [Maaten, Hilton (2008) J of Machine Learning Research](http://jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf) </div>


t-distributed stochastic neighborhood embedding (tSNE) is a **nonlinear** dimensionality reduction technique well-suited for embedding high-dimensional data for **visualization** in a low-dimensional space of two or three dimensions. Specifically, it models each high-dimensional object by a two- or three-dimensional point in such a way that **similar objects are modeled by nearby points** and dissimilar objects are modeled by distant points with high probability. […] t-SNE has been used for visualization in a wide range of applications, including […] bioinformatics […]. While t-SNE plots often seem to display clusters, the **visual clusters can be influenced strongly by the chosen parameterization** and therefore a good understanding of the parameters for t-SNE is necessary. 

<div style="text-align: right"> Adapted from [Wikipedia](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding) </div>


Usefull links:

* [How to Use t-SNE Effectively](https://distill.pub/2016/misread-tsne/)

How to run it:
```{r,  }
SeuratObject <- RunTSNE(object = SeuratObject,
                        reduction = "pca",
                        perplexity=30,
                        max_iter=1000,
                        theta=0.5,
                        eta=200,
                        exaggeration_factor=12,
                        dims.use = 1:50,
                        verbose = T,
                        num_threads=0)
```

<br/> 

<br/> 

## UMAP

Uniform Manifold Approximation and Projection (UMAP) is a dimension reduction technique that can be used for visualisation similarly to t-SNE, but also for general **non-linear** dimension reduction […]. 

<div style="text-align: right"> [umap-learn documentation](https://umap-learn.readthedocs.io/en/latest/) </div>

The result is a practical scalable algorithm that applies to real world data. The UMAP algorithm is competitive with t-SNE for **visualization** quality, and arguably preserves **more of the global structure** with superior run time performance. Furthermore, UMAP has no computational restrictions on embedding dimension, making it viable as a general purpose dimension reduction technique for machine learning. 

<div style="text-align: right"> [UMAP Arxiv paper](https://arxiv.org/pdf/1802.03426.pdf) </div>

How to run it:
```{r,  }
SeuratObject <- RunUMAP(object = SeuratObject,
                        reduction = "pca",
                        dims = 1:top_PCs,
                        n.components = 2,
                        n.neighbors = 20,
                        spread = .3,
                        repulsion.strength = 1,
                        min.dist= .001,
                        verbose = T,
                        num_threads=0,
                        n.epochs = 200,
                        metric = "euclidean",
                        seed.use = 42,
                        reduction.name="umap")
```

<br/> 

<br/> 

## DM

Diffusion maps (DM) is a dimensionality reduction [...] which computes a family of embeddings of a data set into Euclidean space (often low-dimensional) whose coordinates can be computed from the eigenvectors and eigenvalues of a diffusion operator on the data. The Euclidean distance between points in **the embedded space is equal to the "diffusion distance" between probability distributions** centered at those points. Different from linear dimensionality reduction methods such as principal component analysis (PCA) and multi-dimensional scaling (MDS), diffusion maps is part of the family of **nonlinear** dimensionality reduction methods which focus on discovering the underlying manifold that the data has been sampled from. [...] The basic observation is that **if we take a random walk on the data, walking to a nearby data-point is more likely than walking to another that is far away**.

<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/Diffusion_map) </div>


[Diffusion Maps paper](https://www.pnas.org/content/pnas/102/21/7426.full.pdf)

How to run it:
```{r,  }
# Load additional libraries
library(destiny)

#Run diffusion maps using the destiny package 
dm <- DiffusionMap( data = SeuratObject@reductions[["pca"]]@cell.embeddings[ , 1:50],
                    k = 20,
                    n_eigs = 20)

#Fix the cell names in the DM embedding
rownames(dm@eigenvectors) <- colnames(SeuratObject)

#Add the DM embbedding to the SeuratObject
SeuratObject@reductions[["dm"]] <- CreateDimReducObject(embeddings = dm@eigenvectors,
                                                        key = "DC_",
                                                        assay = "RNA")
```

<br/> 

<br/> 


## ICA

Independent Component Analysis (ICA) is a computational method for separating a multivariate signal into additive subcomponents. This is done by assuming that the subcomponents are non-Gaussian signals and that they are statistically independent from each other. ICA is a special case of blind source separation.

<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/Independent_component_analysis) </div>

How to run it:
```{r,  }
SeuratObject <- RunICA(object = SeuratObject,
                       assay = "pca",
                       nics = 20,
                       reduction.name = "ica")

```

<br/> 

<br/> 


# Dataset integration
***

Existing batch correction methods were specifically designed for bulk RNA-seq. Thus, their applications to scRNA-seq data assume that the composition of the cell population within each batch is identical. Any systematic differences in the mean gene expression between batches are attributed to technical differences that can be regressed out. However, in practice, population composition is usually not identical across batches in scRNA-seq studies. Even assuming that the same cell types are present in each batch, the abundance of each cell type in the data set can change depending upon subtle differences in cell culture or tissue extraction, dissociation and sorting, etc. Consequently, the estimated coefficients for the batch blocking factors are not purely technical, but contain a non-zero biological component due to differences in composition. Batch correction based on these coefficients will thus yield inaccurate representations of the cellular expression proles, potentially yielding worse results than if no correction was performed.

<div style="text-align: right"> [Haghverdi et al (2018) *Nat Biotechnology*](https://www.nature.com/articles/nbt.4091) </div>

<br/> 

## MNN

An alternative approach for data merging and comparison in the presence of batch effects uses a set of landmarks from a reference data set to project new data onto the reference. The rationale here is that a given cell type in the reference batch is most similar to cells of its own type in the new batch. This strategy depends on the selection of landmark points in high dimensional space picked from the reference data set, which cover all cell types that might appear in the later batches. However, if the new batches include cell types that fall outside the transcriptional space explored in the reference batch, these cell types will not be projected to an appropriate position in the space defined by the landmarks. [...] The difference in expression values between cells in a MNN pair provides an estimate of the batch effect, which is made more precise by averaging across many such pairs. A correction vector is obtained from the estimated batch effect and applied to the expression values to perform batch correction. Our approach automatically identifies overlaps in population composition between batches and uses only the overlapping subsets for correction, thus avoiding the assumption of equal composition required by other methods.

The use of MNN pairs involves three assumptions: (i) there is at least one cell population that is present in both batches, (ii) the batch effect is almost orthogonal to the biological subspace, and (iii) batch effect variation is much smaller than the biological effect variation between different cell types.

<div style="text-align: right"> [Haghverdi et al (2018) *Nat Biotechnology*](https://www.nature.com/articles/nbt.4091) </div>

```{r,  }
# Load additional libraries
library(SeuratWrappers)

SeuratObject.list <- SplitObject(SeuratObject, split.by = "BATCH")
SeuratObject <- RunFastMNN(object.list = SeuratObject.list,
                           assay = "RNA",
                           features = 2000,
                           reduction.name = "mnn")

# Free memory from working environment
rm( c( SeuratObject.list ) )
gc(verbose = FALSE)
```

## CCA

Since MNNs have previously been identified using L2-normalized gene expression, significant differences across batches can obscure the accurate identification of MNNs, particularly when the batch effect is on a similar scale to the biological differences between cell states. To overcome this, we first jointly reduce the dimensionality of both datasets using diagonalized CCA, then apply L2-normalization to the canonical correlation vectors. We next search for MNNs in this shared low-dimensional represen- tation. We refer to the resulting cell pairs as anchors, as they encode the cellular relationships across datasets that will form the basis for all subsequent integration analyses.

Obtaining an accurate set of anchors is paramount to suc- cessful integration. Aberrant anchors that form between different biological cell states across datasets are analogous to noisy edges that occur in k-nearest neighbor (KNN) graphs (Bendall et al., 2014) and can confound downstream analyses. This has motivated the use of shared nearest neighbor (SNN) graphs (Levine et al., 2015; Shekhar et al., 2016), where the similarity between two cells is assessed by the overlap in their local neigh- borhoods. As this measure effectively pools neighbor informa- tion across many cells, the result is robust to aberrant connec- tions in the neighbor graph. We introduced an analogous procedure for the scoring of anchors, where each anchor pair was assigned a score based on the shared overlap of mutual neighborhoods for the two cells in a pair. High-scoring correspondences therefore represent cases where many similar cells in one dataset are predicted to correspond to the same group of similar cells in a second data- set, reflecting increased robustness in the association between the anchor cells. While we initially identify anchors in low-dimen- sional space, we also filter out anchors whose correspondence is not supported based on the original untransformed data.

<div style="text-align: right"> [Stuart et al (2019) *Cell*](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8) </div>

```{r,  }
SeuratObject.list <- SplitObject(SeuratObject, split.by = "BATCH")

for (i in 1:length(SeuratObject.list)) {
    SeuratObject.list[[i]] <- NormalizeData(SeuratObject.list[[i]], verbose = FALSE)
    SeuratObject.list[[i]] <- FindVariableFeatures(SeuratObject.list[[i]],
                                                   selection.method = "vst",
                                                   nfeatures = 2000,
                                                   verbose = FALSE)
}

hvgs_per_dataset <- lapply(SeuratObject.list, function(x) { x@assays$RNA@var.features })

venn::venn(hvgs_per_dataset,opacity = .4,zcolor = scales::hue_pal()(3),cexsn = 1,cexil = 1,lwd=1,col="white",frame=F,borders = NA)

SeuratObject.anchors <- FindIntegrationAnchors(object.list = SeuratObject.list, dims = 1:30)

SeuratObject.int <- IntegrateData(anchorset = SeuratObject.anchors,
                                  dims = 1:30,
                                  new.assay.name = "cca")
```

<br/> 

<br/> 

## LIGER

<div style="text-align: right"> [Welch et al (2019) *Cell*](https://www.cell.com/cell/pdf/S0092-8674(19)30504-5.pdf) </div>

```{r,  }
# Load additional libraries
library(conos)
library(SeuratWrappers)

# Split the data per batch to be corrected
SeuratObject.list <- SplitObject(SeuratObject, split.by = "Method")
for (i in 1:length(SeuratObject.list)) {
    SeuratObject.list[[i]] <- 
      NormalizeData(SeuratObject.list[[i]]) %>%
      FindVariableFeatures() %>% 
      ScaleData() %>% 
      RunPCA(verbose = FALSE)
}

# Create a Conos object
SeuratObject.con <- Conos$new(SeuratObject.list)

# Build a joint graph across datasets and find shared communities
SeuratObject.con$buildGraph(k = 15, 
                            k.self = 5,
                            space = "PCA",
                            ncomps = 30,
                            n.odgenes = 2000,
                            matching.method = "mNN",
                            metric = "angular",
                            score.component.variance = TRUE,
                            verbose = TRUE)
SeuratObject.con$findCommunities()

# Create a Joint embedding and conver it back to Seurat Object
SeuratObject.con$embedGraph()
SeuratObject <- as.Seurat(SeuratObject.con)

# Free memory from working environment
rm( c( SeuratObject.con, SeuratObject.list ) )
gc(verbose = FALSE)
```

<br/> 

<br/> 

## Conos

<div style="text-align: right"> [Barkas et al (2019) *Nat Methods*](https://www.nature.com/articles/s41592-019-0466-z) </div>

```{r,  }
# Load additional libraries
library(conos)
library(SeuratWrappers)

# Split the data per batch to be corrected
SeuratObject.list <- SplitObject(SeuratObject, split.by = "Method")
for (i in 1:length(SeuratObject.list)) {
    SeuratObject.list[[i]] <- 
      NormalizeData(SeuratObject.list[[i]]) %>%
      FindVariableFeatures() %>% 
      ScaleData() %>% 
      RunPCA(verbose = FALSE)
}

# Create a Conos object
SeuratObject.con <- Conos$new(SeuratObject.list)

# Build a joint graph across datasets and find shared communities
SeuratObject.con$buildGraph(k = 15, 
                            k.self = 5,
                            space = "PCA",
                            ncomps = 30,
                            n.odgenes = 2000,
                            matching.method = "mNN",
                            metric = "angular",
                            score.component.variance = TRUE,
                            verbose = TRUE)
SeuratObject.con$findCommunities()

# Create a Joint embedding and conver it back to Seurat Object
SeuratObject.con$embedGraph()
SeuratObject <- as.Seurat(SeuratObject.con)

# Free memory from working environment
rm( c( SeuratObject.con, SeuratObject.list ) )
gc(verbose = FALSE)
```

<br/> 

<br/> 


## Harmony

<div style="text-align: right"> [Korsunsky et al (2019) *Nat Mathods*](https://www.nature.com/articles/s41592-019-0619-0) </div>


```{r,  }
# Load additional libraries
library(harmony)
library(SeuratWrappers)

SeuratObject <- RunHarmony(SeuratObject, group.by.vars = "Method")
```

<br/> 

<br/> 


# Clustering
***

<br/> 

## Louvain

The Louvain method for community detection is a method to extract communities from large networks created by Blondel et al. from the University of Louvain. The method is a greedy optimization method that appears to run in time $O(n.log^2n)$ in the number of nodes in the network.The value to be optimized is modularity, defined as a value in the range that measures the density of links inside communities compared to links between communities. Optimizing this value theoretically results in **the best possible grouping of the nodes of a given network**, however going through all possible iterations of the nodes into groups is impractical so heuristic algorithms are used.

<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/Independent_component_analysis) </div>


[Louvain Paper](https://iopscience.iop.org/article/10.1088/1742-5468/2008/10/P10008/pdf)

How to run it:
```{r,  }
SeuratObject <- RunICA(object = SeuratObject,
                       assay = "pca",
                       nics = 20,
                       reduction.name = "ica")

```

<br/> 

<br/> 

## Leiden

Leiden algorithm is applied iteratively, it converges to a partition in which all subsets of all communities are locally optimally assigned. Furthermore, by relying on a fast local move approach, the Leiden algorithm runs faster than the Louvain algorithm. The Leiden algorithm consists of three phases: (1) local moving of nodes, (2) refinement of the partition and (3) aggregation of the network based on the refined partition, using the non-refined partition to create an initial partition for the aggregate network.

<div style="text-align: right"> [Leiden Paper](https://www.nature.com/articles/s41598-019-41695-z.pdf) </div>

```{r,  }



```

<br/> 

<br/> 


## Hierachical clustering

Hierachical clustering (HC) is a method of cluster analysis which **seeks to build a hierarchy of clusters**. Strategies for hierarchical clustering generally fall into two types: Agglomerative or Divisive. [...] In general, the merges and splits are determined in a greedy manner. The results of hierarchical clustering are **usually presented in a dendrogram**. [...] The standard algorithm for hierarchical agglomerative clustering (HAC) has a time complexity of $O(n^3)$ and requires $O(n^2)$ memory, which makes it **too slow for even medium data sets**. In order to decide which clusters should be combined (for agglomerative), or where a cluster should be split (for divisive), **a measure of dissimilarity between sets of observations** is required. In most methods of hierarchical clustering, this is achieved by use of an appropriate metric (a measure of distance between pairs of observations), and **a linkage criterion** which specifies the dissimilarity of sets as a function of the pairwise distances of observations in the sets.

<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/Hierarchical_clustering) </div>

[HC for networks](https://en.wikipedia.org/wiki/Hierarchical_clustering_of_networks)

```{r,  }

```

<br/> 

<br/> 

## K-means

k-means clustering is a method of vector quantization, originally from signal processing, that aims to partition $n$ observations into $k$ clusters in which **each observation belongs to the cluster with the nearest mean** (cluster centers or cluster centroid), serving as a prototype of the cluster. [...] The algorithm does not guarantee convergence to the global optimum. The result may depend on the initial clusters. As the algorithm is usually fast, **it is common to run it multiple times** with different starting conditions. [...] k-means clustering tends to find clusters of **comparable spatial extent (all with same size)**, while the expectation-maximization mechanism allows clusters to have different shapes.
<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/K-means_clustering) </div>

```{r,  }

```

<br/> 

<br/> 

## Affinity propagation

In statistics and data mining, affinity propagation (AP) is a clustering algorithm based on the concept of "message passing" between data points. Unlike clustering algorithms such as k-means or k-medoids, affinity propagation **does not require the number of clusters to be determined** or estimated before running the algorithm. Similar to k-medoids, affinity propagation finds "exemplars," members of the input set that are representative of clusters. [...] Iterations are performed until either the cluster boundaries remain unchanged over a number of iterations, or some predetermined number (of interations) is reached.

<div style="text-align: right"> [Wikipedia](https://en.wikipedia.org/wiki/Affinity_propagation) </div>

<br/> 

<br/> 


# Trajectory inference

## Affinity propagation


## Affinity propagation




